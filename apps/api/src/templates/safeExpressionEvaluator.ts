/**
 * Purpose: Provide a safe arithmetic expression evaluator snippet for prompt injection.
 * Persists: None.
 * Security Risks: Guides untrusted artifact generation; must avoid dynamic code execution.
 */

export const SAFE_EXPRESSION_EVALUATOR_SNIPPET = `function computeExpr(input){const src=String(input||"").replace(/\\s+/g,"");const tokens=[];let i=0;while(i<src.length){const ch=src[i];if((ch>="0"&&ch<="9")||ch==="."){let start=i;let seenDot=ch===".";i++;while(i<src.length){const c=src[i];if(c>="0"&&c<="9"){i++;continue;}if(c==="."&&!seenDot){seenDot=true;i++;continue;}break;}const num=Number(src.slice(start,i));if(!Number.isFinite(num)){throw new Error("Invalid number");}tokens.push({t:"num",v:num});continue;}if(ch==="+"||ch==="-"||ch==="*"||ch==="/"){tokens.push({t:"op",v:ch});i++;continue;}if(ch==="("||ch===")"){tokens.push({t:"paren",v:ch});i++;continue;}throw new Error("Invalid character");}const output=[];const ops=[];const prec={"+":1,"-":1,"*":2,"/":2,"u-":3};const isOp=(v)=>v==="+"||v==="-"||v==="*"||v==="/"||v==="u-";for(let idx=0;idx<tokens.length;idx++){const token=tokens[idx];if(token.t==="num"){output.push(token);continue;}if(token.t==="op"){let op=token.v;const prev=tokens[idx-1];const isUnary=op==="-"&&(idx===0||prev.t==="op"||(prev.t==="paren"&&prev.v==="("));if(isUnary){op="u-";}while(ops.length>0){const top=ops[ops.length-1];if(isOp(top)&&prec[top]>=prec[op]){output.push({t:"op",v:ops.pop()});}else{break;}}ops.push(op);continue;}if(token.t==="paren"){if(token.v==="("){ops.push("(");continue;}while(ops.length>0&&ops[ops.length-1]!=="("){output.push({t:"op",v:ops.pop()});}if(ops.pop()!=="("){throw new Error("Mismatched parentheses");}}}while(ops.length>0){const op=ops.pop();if(op==="("){throw new Error("Mismatched parentheses");}output.push({t:"op",v:op});}const stack=[];for(const token of output){if(token.t==="num"){stack.push(token.v);continue;}const op=token.v;if(op==="u-"){if(stack.length<1){throw new Error("Invalid expression");}stack.push(-stack.pop());continue;}if(stack.length<2){throw new Error("Invalid expression");}const b=stack.pop();const a=stack.pop();switch(op){case "+":stack.push(a+b);break;case "-":stack.push(a-b);break;case "*":stack.push(a*b);break;case "/":stack.push(a/b);break;default:throw new Error("Invalid operator");}}if(stack.length!==1||!Number.isFinite(stack[0])){throw new Error("Invalid expression");}return stack[0];}`;
